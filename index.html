<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remove Background Color</title>
    <style>
        #copyright,
        body,
        h1,
        h2 {
            color: #fff
        }

        body {
            background-color: #333;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            line-height: 1.6
        }
        a:link {
         color: #BBB;
        }
        #copyright {
            margin-top: 30px;
            text-align: center;
            font-size: 14px
        }
    </style>
</head>

<body>
    <h1>Background Remover</h1>
    <div>
        <input type="file" id="imageUpload" accept="image/*">
        <div style="margin:10px 0">
            <label style="color:#fff">
                <input type="radio" name="bgColor" value="white" checked>White</label>
            <label style="color:#fff;margin-left:15px">
                <input type="radio" name="bgColor" value="black">Black</label>
            <label style="color:#fff;margin-left:15px">
                <input type="radio" name="bgColor" value="grayscale">Grayscale</label>
        </div>
        <button id="downloadBtn" disabled>Save Result</button>
        <div id="processingTime" style="color:#fff;margin-top:10px">
        </div>
    </div>
    <div>
        <h2>Original</h2>
        <img id="originalPreview" style="max-width: 100px; max-height: 100px; display: none;">
        <h2>Processed</h2>
        <img id="processedPreview" style="max-width: 100px; max-height: 100px; display: none;">
    </div>
    <div id="copyright">Â© Lanczos, 2025 <a href="https://github.com/LukaLanczos/Remove-White-Background">GitHub</div>

    <script>
        // Get DOM elements
        const imageUpload = document.getElementById('imageUpload');
        const downloadBtn = document.getElementById('downloadBtn');
        const originalPreview = document.getElementById('originalPreview');
        const processedPreview = document.getElementById('processedPreview');
        const processingTime = document.getElementById('processingTime');
        const bgColorRadios = document.getElementsByName('bgColor');
        
        // Current image data being processed
        let currentImage = null;
        let currentImageDataURL = null;
        
        // Main image processing function
        function processImage(image, targetColor, inputImageData = null) {
            // Create canvas element for image manipulation
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            let imageData;
            
            if (inputImageData) {
                // Use provided ImageData directly
                canvas.width = inputImageData.width;
                canvas.height = inputImageData.height;
                imageData = inputImageData;
            } else {
                // Create ImageData from image
                canvas.width = image.width;
                canvas.height = image.height;
                ctx.drawImage(image, 0, 0);
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Check if contains transparency
                let hasTransparency = false;
                const data = imageData.data;
                for (let i = 3; i < data.length; i += 4) {
                    if (data[i] < 255) {
                        hasTransparency = true;
                        break;
                    }
                }
                
                // If has, composite with bg
                if (hasTransparency) {
                    // Create temporary for drawing target bg
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    
                    tempCtx.fillStyle = `rgb(${targetColor.r * 255}, ${targetColor.g * 255}, ${targetColor.b * 255})`;
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // Draw original
                    tempCtx.drawImage(image, 0, 0);
                    
                    // Get new img data
                    imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                }
            }
            
            const data = imageData.data;
            
            // Iterate through each pixel (4 elements per pixel: R, G, B, A)
            for (let i = 0; i < data.length; i += 4) {
                // Get current pixel RGB values (normalized to 0-1)
                const r_in = data[i] / 255;
                const g_in = data[i + 1] / 255;
                const b_in = data[i + 2] / 255;
                
                // Target background color RGB components
                const { r: r_bg, g: g_bg, b: b_bg } = targetColor;
                
                // 1. Calculate alpha channel value (based on maximum deviation from background color)
                let alpha_r = 0, alpha_g = 0, alpha_b = 0;
                
                // Calculate alpha for red
                if (r_bg < 1) alpha_r = Math.max(0, (r_in - r_bg) / (1 - r_bg));
                if (r_bg > 0) alpha_r = Math.max(alpha_r, (r_bg - r_in) / r_bg);
                
                // Calculate alpha for green
                if (g_bg < 1) alpha_g = Math.max(0, (g_in - g_bg) / (1 - g_bg));
                if (g_bg > 0) alpha_g = Math.max(alpha_g, (g_bg - g_in) / g_bg);
                
                // Calculate alpha for blue
                if (b_bg < 1) alpha_b = Math.max(0, (b_in - b_bg) / (1 - b_bg));
                if (b_bg > 0) alpha_b = Math.max(alpha_b, (b_bg - b_in) / b_bg);
                
                // Take the maximum alpha value from the 3 color channels
                const alpha = Math.max(alpha_r, alpha_g, alpha_b);
                
                // Clamp alpha value to 0-1 range to prevent precision errors
                const final_alpha = Math.max(0, Math.min(1, alpha));
                
                // 2. Calculate new foreground color (reverse premultiplication)
                let r_out, g_out, b_out;
                if (final_alpha < 1e-6) {
                    // If almost completely transparent, color values don't matter, set to 0
                    r_out = g_out = b_out = 0;
                } else {
                    // Calculate actual foreground based on alpha value
                    r_out = (r_in - r_bg * (1 - final_alpha)) / final_alpha;
                    g_out = (g_in - g_bg * (1 - final_alpha)) / final_alpha;
                    b_out = (b_in - b_bg * (1 - final_alpha)) / final_alpha;
                }
                
                // 3. Write the calculated new RGBA values back to pixel data
                data[i] = Math.max(0, Math.min(255, r_out * 255)); // Red component
                data[i + 1] = Math.max(0, Math.min(255, g_out * 255)); // Green component
                data[i + 2] = Math.max(0, Math.min(255, b_out * 255)); // Blue component
                data[i + 3] = final_alpha * 255; // Alpha channel
            }
            
            // Put processed img data back to canvas
            ctx.putImageData(imageData, 0, 0);
            
            // Return processed img data
            return {
                imageData: imageData,
                dataURL: canvas.toDataURL('image/png')
            };
        }
        
        // Process image based on selection
        function processImageWithMode() {
            if (!currentImage) return;
            
            const startTime = performance.now();
            
            // Get selected
            let selectedMode = 'white';
            for (const radio of bgColorRadios) {
                if (radio.checked) {
                    selectedMode = radio.value;
                    break;
                }
            }
            
            let result;
            
            if (selectedMode === 'white') {
                // White removal
                const targetColor = { r: 1, g: 1, b: 1 };
                result = processImage(currentImage, targetColor);
            } else if (selectedMode === 'black') {
                // Black removal
                const targetColor = { r: 0, g: 0, b: 0 };
                result = processImage(currentImage, targetColor);
            } else if (selectedMode === 'grayscale') {
                // Grayscale: remove white first, then black
                const whiteColor = { r: 1, g: 1, b: 1 };
                const blackColor = { r: 0, g: 0, b: 0 };
                
                // Step 1: Remove white
                const step1Result = processImage(currentImage, whiteColor);
                
                // Step 2: Remove black using step 1 result as input
                const tempImage = new Image();
                tempImage.src = step1Result.dataURL;
                tempImage.onload = function() {
                    result = processImage(tempImage, blackColor);
                    
                    // Update preview and download link
                    updatePreviewAndDownload(result.dataURL);
                    
                    // Calculate and display processing time
                    const endTime = performance.now();
                    const timeTaken = (endTime - startTime).toFixed(2);
                    processingTime.textContent = `Time: ${timeTaken} ms`;
                };
                return; // Return early, wait for step 2 to complete
            }
            
            // Update preview and dl link
            updatePreviewAndDownload(result.dataURL);
            
            // Calculate and display time
            const endTime = performance.now();
            const timeTaken = (endTime - startTime).toFixed(2);
            processingTime.textContent = `Time: ${timeTaken} ms`;
        }
        
        // Update preview and dl link
        function updatePreviewAndDownload(dataURL) {
            // Display preview
            processedPreview.src = dataURL;
            processedPreview.style.display = 'block';
            
            // Enable download
            downloadBtn.disabled = false;
            
            // Save current result
            currentImageDataURL = dataURL;
            
            // Setup download functionality
            downloadBtn.onclick = function() {
                const a = document.createElement('a');
                a.href = dataURL;
                
                // Generate filename
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                
                const filename = `IMG_${year}${month}${day}_${hours}${minutes}${seconds}.png`;
                a.download = filename;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            };
        }
        
        // Handle file upload
        imageUpload.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    // Save current img
                    currentImage = img;
                    
                    // Display original preview
                    originalPreview.src = event.target.result;
                    originalPreview.style.display = 'block';
                    
                    // Process img
                    processImageWithMode();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
        
        // Re-process when option changes
        for (const radio of bgColorRadios) {
            radio.addEventListener('change', function() {
                if (currentImage) {
                    processImageWithMode();
                }
            });
        }
    </script>
</body>

</html>